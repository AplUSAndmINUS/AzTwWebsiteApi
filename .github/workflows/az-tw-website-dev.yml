name: Azure Function App Dev Deployment

on:
  push:
    branches:
      - development
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './src/Functions'
  OUTPUT_PATH: './output'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: development

    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    - name: Setup DotNet ${{ env.DOTNET_VERSION }} Environment
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Build and Publish Functions'
      shell: bash
      env:
        FUNCTIONS_WORKER_RUNTIME: "dotnet-isolated"
        DOTNET_SYSTEM_GLOBALIZATION_INVARIANT: 1
      run: |
        # Clean output directory
        rm -rf ./output
        mkdir -p ./output

        # Build solution
        echo "üî® Building solution..."
        dotnet restore AzTwWebsiteApi.sln
        dotnet clean AzTwWebsiteApi.sln --configuration Release
        dotnet build AzTwWebsiteApi.sln --configuration Release
        
        # Publish functions
        echo "üì¶ Publishing functions..."
        dotnet publish src/Functions/Blog/BlogFunctions.csproj \
          --configuration Release \
          --output ./output \
          --runtime linux-x64 \
          --self-contained false \
          -p:PublishReadyToRun=false \
          -p:GenerateRuntimeConfigurationFiles=true \
          -p:UseAppHost=false
        
        # Verify function.json files
        echo "üîç Checking for function.json files..."
        find ./output -name "function.json" -type f -exec echo "Found: {}" \; -exec cat {} \;
        
        # Ensure proper function app structure
        echo "ÔøΩ Setting up function app structure..."
        
        # Copy host.json
        cp src/Functions/Blog/host.json ./output/
        
        # Create minimal local.settings.json
        echo '{
          "IsEncrypted": false,
          "Values": {
            "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated",
            "AzureWebJobsStorage": "",
            "FUNCTIONS_EXTENSION_VERSION": "~4",
            "WEBSITE_RUN_FROM_PACKAGE": "1"
          }
        }' > ./output/local.settings.json
        
        # Create deployment package
        echo "üì¶ Creating deployment package..."
        cd ./output
        zip -r ../function-app.zip ./*
        cd ..
        
        echo "üì¶ Deployment package contents:"
        unzip -l function-app.zip
        if [ -f function-app.zip ]; then
          echo "‚úÖ function-app.zip created successfully!"
        else
          echo "‚ùå ZIP creation failed!"
          exit 1
        fi

    - name: 'Pre-deployment Check'
      shell: bash
      run: |
        echo "üìù Checking Function App configuration..."
        az functionapp config show \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "{runtime:linuxFxVersion,platform:use32BitWorkerProcess}"

        echo "üì¶ Verifying package contents..."
        ls -la ./output
        
        echo "üîß Checking host.json..."
        cat ./output/host.json

    - name: 'Configure Function App Settings'
      shell: bash
      run: |
        echo "‚öôÔ∏è Configuring Function App settings..."
        echo "Function App Name: ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }}"
        echo "Resource Group: ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }}"
        echo "Storage Account Name: ${{ vars.STORAGE_ACCOUNT_NAME }}"
        echo "Storage Connection String: ${{ secrets.STORAGE_CONNECTION_STRING }}"
        # Configure function app for Linux and .NET 8.0
        az functionapp config set \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --linux-fx-version "DOTNET-ISOLATED|8.0" \
          --net-framework-version "v8.0" \
          --use-32bit-worker-process false

        # Set content share name based on function app name
        CONTENT_SHARE="${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }}-content"

        # Configure application settings
        az functionapp config appsettings set \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --settings \
            AzureWebJobsStorage="${{ secrets.STORAGE_CONNECTION_STRING }}" \
            WEBSITE_CONTENTAZUREFILECONNECTIONSTRING="${{ secrets.STORAGE_CONNECTION_STRING }}" \
            WEBSITE_CONTENTSHARE="$CONTENT_SHARE" \
            FUNCTIONS_EXTENSION_VERSION="~4" \
            FUNCTIONS_WORKER_RUNTIME="dotnet-isolated" \
            WEBSITE_RUN_FROM_PACKAGE="1" \
            SCM_DO_BUILD_DURING_DEPLOYMENT="false" \
            ENABLE_ORYX_BUILD="false" \
            StorageAccountName="${{ vars.STORAGE_ACCOUNT_NAME }}"

    - name: 'Deploy to Azure Function App'
      uses: Azure/functions-action@v1
      id: deploy
      with:
        app-name: ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }}
        package: ./function-app.zip
        respect-funcignore: true
        scm-do-build-during-deployment: false
        enable-oryx-build: false

    - name: 'Verify Deployment'
      if: always()
      shell: bash
      run: |
        echo "‚è≥ Waiting for deployment to stabilize..."
        sleep 30

        # Check Function App status first
        echo "üîç Checking Function App status..."
        function_status=$(az functionapp show \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "state" -o tsv)

        if [[ "$function_status" != "Running" ]]; then
          echo "‚ùå Function App is not in Running state. Current state: $function_status"
          exit 1
        fi

        echo "‚úÖ Function App is running"

        # Check deployment status using kudu API
        echo "üìã Checking deployment status..."
        deployment_id=$(az functionapp deployment list \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "[0].id" -o tsv)

        if [[ -z "$deployment_id" ]]; then
          echo "‚ùå No deployments found"
          exit 1
        fi

        deployment_status=$(az functionapp deployment show \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --deployment-id $deployment_id \
          --query "status" -o tsv)

        if [[ "$deployment_status" != "Success" ]]; then
          echo "‚ùå Latest deployment is not successful. Status: $deployment_status"
          echo "üìú Fetching deployment logs..."
          az functionapp deployment list \
            --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
            --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
            --output table
          exit 1
        fi

        # Verify function runtime and version
        echo "üîç Verifying function runtime configuration..."
        runtime_config=$(az functionapp config show \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "{linuxFxVersion:linuxFxVersion,netFrameworkVersion:netFrameworkVersion}" -o json)

        linux_fx_version=$(echo $runtime_config | jq -r .linuxFxVersion)
        net_framework_version=$(echo $runtime_config | jq -r .netFrameworkVersion)

        if [[ "$linux_fx_version" != "DOTNET-ISOLATED|8.0" ]]; then
          echo "‚ùå Incorrect Linux FX Version. Expected: DOTNET-ISOLATED|8.0, Got: $linux_fx_version"
          exit 1
        fi

        echo "‚úÖ Deployment verification successful!"
        echo "üìã Deployment Summary:"
        echo "- Function App State: $function_status"
        echo "- Deployment Status: $deployment_status"
        echo "- Runtime Version: $linux_fx_version"
        echo "- .NET Version: $net_framework_version"

    - name: 'Verify Content Share'
      if: always()
      shell: bash
      run: |
        echo "üîç Verifying content share..."
        CONTENT_SHARE="${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }}-content"
        
        # Check if content share exists
        az storage share exists \
          --name "$CONTENT_SHARE" \
          --account-name "${{ vars.STORAGE_ACCOUNT_NAME }}" \
          --account-key $(az storage account keys list \
            --account-name "${{ vars.STORAGE_ACCOUNT_NAME }}" \
            --resource-group "${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }}" \
            --query "[0].value" -o tsv) \
          --query "exists" -o tsv

        # Check exit code
        if [ $? -eq 0 ]; then
          echo "‚úÖ Content share '$CONTENT_SHARE' exists and is accessible"
        else
          echo "‚ùå Content share verification failed"
          exit 1
        fi

    - name: 'Sync Function Triggers'
      if: success()
      shell: bash
      run: |
        echo "üîÑ Preparing to sync function triggers..."

        # Get publishing credentials
        echo "üîê Getting publishing credentials..."
        creds=$(az functionapp deployment list-publishing-credentials \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "{publishingUserName:publishingUserName,publishingPassword:publishingPassword}" -o json)

        USERNAME=$(echo $creds | jq -r .publishingUserName)
        PASSWORD=$(echo $creds | jq -r .publishingPassword)

        if [[ -z "$USERNAME" ]] || [[ -z "$PASSWORD" ]]; then
          echo "‚ùå Failed to get publishing credentials"
          exit 1
        fi

        # Sync triggers
        echo "üîÑ Syncing function triggers..."
        sync_response=$(curl -s -w "\n%{http_code}" \
          -X POST \
          -u "$USERNAME:$PASSWORD" \
          "https://${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }}.scm.azurewebsites.net/api/functions/synctriggers")
        
        status_code=$(echo "$sync_response" | tail -n1)
        response_body=$(echo "$sync_response" | head -n-1)

        if [[ "$status_code" != "200" ]]; then
          echo "‚ùå Trigger sync failed with status $status_code"
          echo "Response: $response_body"
          exit 1
        fi

        echo "‚è≥ Waiting for sync to complete..."
        sleep 30

        # List functions
        echo "üìã Listing functions..."
        functions=$(az functionapp function list \
          --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
          --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
          --query "[].{name:name,trigger:config.bindings[0].type}" -o json)

        if [[ $(echo "$functions" | jq length) -eq 0 ]]; then
          echo "‚ö†Ô∏è No functions found. Checking function app logs..."
          echo "üìú Recent function app logs:"
          az webapp log tail \
            --name ${{ vars.AZURE_FUNCTIONAPP_NAME_DEV }} \
            --resource-group ${{ vars.RESOURCE_GROUP_FUNCTIONS_NAME }} \
            --provider http \
            --limit 50
        else
          echo "‚úÖ Functions found:"
          echo "$functions" | jq -r '.[] | "- \(.name) [\(.trigger)]"'
        fi
    - name: 'Report Deployment Status'
      if: always()
      shell: bash
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Deployment completed successfully"
        else
          echo "‚ùå Deployment failed"
          exit 1
        fi